<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 rel. 4 U (http://www.xmlspy.com) by Kev O'Neill (CCLRC) -->
<xs:schema targetNamespace="http://ndg.nerc.ac.uk/moles" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:moles="http://ndg.nerc.ac.uk/moles" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.03">
	<xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="http://www.isotc211.org/2005/xlink/xlinks.xsd"/>
	<!--version 1.03 of NDG metadata schema. Modifications from 1.02.05:
		removal of dgDataObjectType
		introduction of dgParameterValue into dgParameterType to force values a level down
		introduction of dgParameterValueType
		introduction of:
			dgValueDataParameterType
			dgRangeDataParameterType
			dgEnumerationParameterType
			dgParameterGroupType
		extension of dgDataSetType to include feature type list
		extension to dgMetadataProvenance:
			MetadataLanguage
		extension of dgDatasetProvenance in dgDataSummary:
			dgDataPublicationDate
			dgDataLanguage
		rework online reference type to:
			move current content of type into element dgSimpleLink
			include dgCitation
			include dgReferenceClass
			include dgReferenceName
		add optional description to dgGranuleSummary
		make dgDataGranule optional, for those cases where the dataset is catalogued, but not accessible,
			or is "virtual"
		rename dgRelatedDataEntity/RelatedDataGranuleID to	dgRelatedDataEntity/RelatedDataEntityID
		change type of DQStatementReference to dgOnlineReferenceType
		add logo elements to dgOrganisation
		default added to "isOutput" in parameter summary
		added std brackets, colon, and percent sign to permissible regular expression in identifiers
		Refinement to add longitudeDecimalType and latitudeDecimalType to limit values, and consequent
			change of type for lat/long related elements
		Correct placement of dgDatasetLanguage element
			-->
	<xs:element name="dgMetadata">
		<xs:annotation>
			<xs:documentation>Root element of schema - xlink  - location . = http://www.isotc211.org/2005</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence minOccurs="0">
				<xs:element name="dgMetadataRecord" type="moles:dgMetadataRecordType" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Specialises to give the metadata entities that we're really interested in.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="moles:dgPerson" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="moles:dgOrganisation" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="version" type="xs:string" default="1.03"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="dgStructuredKeyword" type="moles:dgStructuredKeywordType">
		<xs:annotation>
			<xs:documentation>An entry in an identified structured keyword list. </xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="dgStructuredKeywordType">
		<xs:sequence>
			<xs:element name="dgValidTerm" type="xs:string"/>
			<xs:element name="dgValidTermID" type="moles:dgValidTermIDType"/>
			<xs:element name="dgValidTermAbbrev" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>We'll avoid synonyms for now...</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgValidTermParentID" type="moles:dgValidTermIDType" minOccurs="0"/>
			<xs:element name="dgValidSubterm" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="ListLevel" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Zero is root, and add one as you go down...</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Definition" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgDeploymentType">
		<xs:sequence>
			<xs:element name="DateStart" type="xs:date"/>
			<xs:element name="DateEnd" type="xs:date" minOccurs="0"/>
			<xs:element ref="moles:dgMetadataID"/>
			<xs:element name="ActivityID" type="moles:dgMetadataIDType"/>
			<xs:element name="DataProductionToolID" type="moles:dgMetadataIDType"/>
			<xs:element name="ObservationStationID" type="moles:dgMetadataIDType"/>
			<xs:element name="Coverage" type="moles:dgCoverageType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="dgMetadataID" type="moles:dgMetadataIDType">
		<xs:annotation>
			<xs:documentation>Intended to be globally unique, yet allow local repositories to carry on as normal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="dgMetadataIDType">
		<xs:annotation>
			<xs:documentation>ObjectID for all metadata objects</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="schemeIdentifier">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="URI"/>
						<xs:enumeration value="NDG-A0"/>
						<xs:enumeration value="NDG-B0"/>
						<xs:enumeration value="NDG-B1"/>
						<xs:enumeration value="CDML-0"/>
						<xs:enumeration value="DIF"/>
						<xs:enumeration value="ISO19115"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="repositoryIdentifier">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:pattern value="[a-zA-Z][a-zA-Z0-9.\-/_:%]*"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:element name="localIdentifier">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:pattern value="[a-zA-Z][a-zA-Z0-9.\-/_:%()]*"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgRoleType">
		<xs:sequence>
			<xs:element ref="moles:dgMetadataID"/>
			<xs:element name="roleName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Standard name of the role throughout the NDG</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="abbreviation" type="xs:string"/>
			<xs:element name="dgRoleHolder" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Key is the holder and start date</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:choice>
							<xs:element name="dgOrganisationID" type="moles:dgMetadataIDType"/>
							<xs:element name="dgPersonID" type="moles:dgMetadataIDType"/>
							<xs:element name="dgRoleID" type="moles:dgMetadataIDType">
								<xs:annotation>
									<xs:documentation>Pointer to another role that must be stored within the system somewhere</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
						<xs:element name="startDate" type="xs:date"/>
						<xs:element name="endDate" type="xs:date" minOccurs="0"/>
						<xs:element name="localName" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Title under which the role is being executed, with a default to the standard name</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="contactDetails" type="moles:dgContactDetailType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgContactDetailType">
		<xs:sequence>
			<xs:element name="eMail" type="xs:string" minOccurs="0"/>
			<xs:element name="fax" type="xs:string" minOccurs="0"/>
			<xs:element name="telephone" type="xs:string" minOccurs="0"/>
			<xs:element name="address" type="moles:dgAddressType" minOccurs="0"/>
			<xs:element name="URI" type="xs:anyURI" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgAddressType">
		<xs:sequence>
			<xs:element name="addressline" type="xs:string" maxOccurs="unbounded"/>
			<xs:element name="city" type="xs:string"/>
			<xs:element name="postcode" type="xs:string" minOccurs="0"/>
			<xs:element name="country" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgPersonalNameType">
		<xs:sequence>
			<xs:element name="title" type="xs:string" minOccurs="0"/>
			<xs:element name="knownAs" type="xs:string" minOccurs="0"/>
			<xs:element name="personalName" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="initials" type="xs:string"/>
			<xs:element name="familyName" type="xs:string"/>
			<xs:element name="nameOrder" default="L2R">
				<xs:annotation>
					<xs:documentation>order of names to allow for east/west difference</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="L2R"/>
						<xs:enumeration value="R2L"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgCoverageType">
		<xs:annotation>
			<xs:documentation>This is to allow the statement of the coverage. We will start minimally, and extend as required.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="moles:dgSpatialCoverage" minOccurs="0"/>
			<xs:element ref="moles:dgTemporalCoverage" minOccurs="0"/>
			<xs:element name="dgSpatioTemporalCoverage" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Where there is a connection between spatial and temporal elements</xs:documentation>
					<xs:documentation>Where there is a connection between spatial and temporal elements</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence maxOccurs="unbounded">
						<xs:element name="dgSpatioTemporalRange">
							<xs:complexType>
								<xs:sequence>
									<xs:element ref="moles:dgSpatialCoverage"/>
									<xs:element ref="moles:dgTemporalCoverage"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgUnitType">
		<xs:annotation>
			<xs:documentation>Restriction of a term to allow a pointer to the definitive list (which will be "hard-wired" when it is fully agreed and set up)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="moles:dgStructuredKeywordType">
				<xs:sequence>
					<xs:element name="dgValidTerm" type="xs:string"/>
					<xs:element name="dgValidTermID" type="moles:dgValidTermIDType"/>
					<xs:element name="dgValidTermAbbrev" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation>We'll avoid synonyms for now...</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="dgOrganisationType">
		<xs:sequence>
			<xs:element ref="moles:dgMetadataID"/>
			<xs:element name="name"/>
			<xs:element name="abbreviation"/>
			<xs:element name="contactDetails" type="moles:dgContactDetailType"/>
			<xs:element name="dgOrganisationRole" type="moles:dgRoleType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="moles:logos" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgPersonType">
		<xs:sequence>
			<xs:element name="name" type="moles:dgPersonalNameType"/>
			<xs:element name="contactDetails" type="moles:dgContactDetailType"/>
			<xs:element ref="moles:dgMetadataID"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="dgPerson" type="moles:dgPersonType">
		<xs:annotation>
			<xs:documentation>Here to allow inclusion in schema.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="dgOrganisation" type="moles:dgOrganisationType">
		<xs:annotation>
			<xs:documentation>Here to allow inclusion in schema.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="dgMetadataDescriptionType">
		<xs:sequence>
			<xs:element name="metadataDescriptionID" type="moles:dgMetadataIDType"/>
			<xs:element name="metadataDescriptionLastUpdated" type="xs:date"/>
			<xs:element name="abstract">
				<xs:annotation>
					<xs:documentation>This is really the "NDG definitive" description.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:sequence>
							<xs:element name="abstractText" type="xs:string"/>
							<xs:element ref="moles:contentType" minOccurs="0"/>
						</xs:sequence>
						<xs:element name="abstractOnlineReference" type="moles:dgOnlineReferenceType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="descriptionSection" minOccurs="0" maxOccurs="unbounded">
				<xs:complexType>
					<xs:choice>
						<xs:sequence>
							<xs:element name="dgDescriptionText"/>
							<xs:element ref="moles:contentType" minOccurs="0"/>
						</xs:sequence>
						<xs:element name="descriptionOnlineReference" type="moles:dgOnlineReferenceType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgSpatialCoverageType">
		<xs:sequence>
			<xs:sequence>
				<xs:element name="BoundingBox" type="moles:dgBoundingBoxType" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Limits are in terms of lat/long. Note the limitations of these in searching certain parts of the globe.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="dgArea" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>A geographical area as defined by a controlled vocabulary</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="dgCourse" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Note that there's only a 2D course in there at the moment. In principle you might want a 2D course and a 3D course (e.g. track of aircraft on ground and trajectory through air)</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:choice>
							<xs:element name="dgCourse2D" type="moles:dgCourse2DType"/>
							<xs:element name="dgCoursePlotURI" type="moles:dgOnlineReferenceType"/>
						</xs:choice>
					</xs:complexType>
				</xs:element>
				<xs:element name="dgPolygon2D" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:complexContent>
							<xs:extension base="moles:dgPolygon2DType"/>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:element name="dgVerticalExtent" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dgVerticalExtentBaseRef" type="moles:dgStructuredKeywordType">
							<xs:annotation>
								<xs:documentation>Statement of where the "zero-point" is from, would you believe it, a vocab</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:choice>
							<xs:annotation>
								<xs:documentation>All values, except verticalExtentText, are assumed to be in metres unless otherwise stated</xs:documentation>
							</xs:annotation>
							<xs:element name="dgVerticalExtentLevel" minOccurs="0" maxOccurs="unbounded">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="verticalExtentLevelValue"/>
										<xs:element name="verticalExtentLevelUnit" type="moles:dgUnitType" minOccurs="0"/>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
							<xs:element name="dgVerticalExtentRange" minOccurs="0" maxOccurs="unbounded">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="verticalExtentRangeMin" type="xs:decimal"/>
										<xs:element name="verticalExtentRangeMax" type="xs:decimal"/>
										<xs:element name="verticalExtentRangeUnit" type="moles:dgUnitType" minOccurs="0"/>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:choice>
						<xs:element name="dgVerticalExtentText" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Note that these terms should all be from the same vocab.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="dgSpatialResolution" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="xResolution" type="moles:dgResolutionType"/>
						<xs:element name="yResolution" type="moles:dgResolutionType"/>
						<xs:element name="zResolution" type="moles:dgResolutionType"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="dgSpatialCoverage" type="moles:dgSpatialCoverageType">
		<xs:annotation>
			<xs:documentation>Note that no provision is currently made for different CRS. The standard here is lat/long. This will provide a base for transation at the front-ends via the standard libraries and functions.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="dgTemporalCoverage" type="moles:dgTemporalCoverageType">
		<xs:annotation>
			<xs:documentation>Note that no provision is currently made for different CRS. The standard here is UTC. This will provide a base for transation at the front-ends. Special calendars are part of the modelling definition.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="dgValidTermIDType">
		<xs:sequence>
			<xs:element name="ParentListID" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Reference to location of the defining list to which the term belongs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TermID" type="xs:string">
				<xs:annotation>
					<xs:documentation>Value assigned, unique  within a particular term list</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgTemporalCoverageType">
		<xs:sequence>
			<xs:choice>
				<xs:element name="DateRange" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Note that a single year/month will be dealt with as a date range</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="DateRangeStart" type="xs:date"/>
							<xs:element name="DateRangeEnd" type="xs:date"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="DateSingle" type="xs:date" minOccurs="0" maxOccurs="unbounded"/>
			</xs:choice>
			<xs:element name="dgChronostratigraphicTerm" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Keyword for palaeo temporal eras covered by data. Will be from a specific vocab</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgTemporalResolution" type="moles:dgResolutionType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgParameterType">
		<xs:sequence>
			<xs:element name="IsOutput" type="xs:boolean" default="true" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Whether the parameter described was "fixed" or generated by the measurement.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgParameterValue" type="moles:dgParameterValueType"/>
			<xs:element name="dgStdParameterMeasured" type="moles:dgStructuredKeywordType" maxOccurs="unbounded"/>
			<xs:element name="ParameterName" type="xs:string"/>
			<xs:element name="ParameterAbbreviation" type="xs:string"/>
			<xs:element name="ParameterLevel" type="xs:integer" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>This is to allow you to know  how far down the potential parameter tree you are, to help with parameter groups. Top level is level 0 (the default)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="contentType">
		<xs:annotation>
			<xs:documentation>This can only contain values from the official MIME list. See http://www.iana.org/assignments/media-types and be limited to: application/xhtml+xml; text/plain.</xs:documentation>
		</xs:annotation>
		<xs:simpleType>
			<xs:restriction base="xs:string">
				<xs:enumeration value="text/plain"/>
				<xs:enumeration value="application/xhtml+xml"/>
			</xs:restriction>
		</xs:simpleType>
	</xs:element>
	<xs:complexType name="dgResolutionType">
		<xs:choice>
			<xs:element name="resolutionTerm" type="moles:dgStructuredKeywordType"/>
			<xs:element name="resolutionValue">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="resolutionDistance" type="xs:decimal"/>
						<xs:element name="resolutionUnit" type="moles:dgUnitType"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="resolutionScaleDenominator" type="xs:decimal"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="dgSecurityConditionType">
		<xs:sequence>
			<xs:element name="effect">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="allow"/>
						<xs:enumeration value="deny"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
			<xs:choice>
				<xs:element name="simpleCondition">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="dgAttributeAuthority" type="xs:string"/>
							<xs:element name="attrauthRole" type="xs:string"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="complexCondition">
					<xs:annotation>
						<xs:documentation>Place holder for when complex conditions arise</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="conditionExplanationText" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Text to state condition in free text. This should allow it to be output to the relevant elements of things like GCMD DIF</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>	
	<xs:complexType name="dgPolygon2DType">
		<xs:annotation>
			<xs:documentation>A gross simplification, but should be enough for discovery. Note that this is the outer boundary. Note "isInclusive" attribute that must be (un)set to exclude an area. This does not allow nesting of extents, but this is not felt to be necessary for discovery.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="point2D" type="moles:dgPoint2DType" minOccurs="3" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Note that order IS significant. First point is the starting point, and the others follow in order, with closure from the last to first point. X and Y are Lat/Long in decimal degrees</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgInternalPoint" type="moles:dgPoint2DType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional point that is unambiguously inside the area for those "difficult cases"</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="moles:dgSpatialInclusionAttrGrp"/>
	</xs:complexType>
	<xs:complexType name="dgCitationType">
		<xs:annotation>
			<xs:documentation>Note that these citations are intended to be "atomic". That is, that there is no attempt to link together editions for the same work. External systems should deal with this.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="workTitle" type="xs:string"/>
			<xs:element name="citationIdentifier" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Lists the various citation identifiers recognised by NDG</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="citationIdentifierScheme">
							<xs:annotation>
								<xs:documentation>String identifying identifier scheme, which really should be a namespace, but will stick with enumeration for now...</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="URI"/>
									<xs:enumeration value="DOI"/>
									<xs:enumeration value="ARK"/>
									<xs:enumeration value="URN"/>
									<xs:enumeration value=""/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
						<xs:element name="citationIdentifierString">
							<xs:annotation>
								<xs:documentation>A valid identifier in the scheme indicated above as a string.</xs:documentation>
							</xs:annotation>
							<xs:complexType/>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="editionIdentifier" type="xs:string" minOccurs="0"/>
			<xs:element name="editionDate" type="xs:date" minOccurs="0"/>
			<xs:element name="authors">
				<xs:complexType>
					<xs:sequence maxOccurs="unbounded">
						<xs:element name="author">
							<xs:complexType>
								<xs:sequence>
									<xs:choice>
										<xs:element name="nonPersonalAuthorName">
											<xs:annotation>
												<xs:documentation>For authors who are not people, e.g. BODC...</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="authorName" type="moles:dgPersonalNameType"/>
									</xs:choice>
									<xs:element name="authorOrdinal" type="xs:int" default="1">
										<xs:annotation>
											<xs:documentation>First author = 1, second = 2, etc...</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="authorCount" type="xs:int" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgCourse2DType">
		<xs:annotation>
			<xs:documentation>Note that point order IS significant. First point is the starting point, and the others follow in order. Note that there is no closure from the last to first listed points, unlike polygons.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="point2D" type="moles:dgPoint2DType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgPoint2DType">
		<xs:annotation>
			<xs:documentation>co-ordinate system is "lat/long"</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="point2Dx" type="moles:longitudeDecimalType"/>
			<xs:element name="point2Dy" type="moles:latitudeDecimalType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:attributeGroup name="dgSpatialInclusionAttrGrp">
		<xs:annotation>
			<xs:documentation>Set of attributes to resolve issues that there may be in searching for this extent</xs:documentation>
		</xs:annotation>
		<xs:attribute name="isInclusive" type="xs:boolean" use="optional" default="true">
			<xs:annotation>
				<xs:documentation>Clear to statement to make explicit the "obvious" :-)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="includesNorthPole" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>Statement as to whether the North Pole is within the extent being searched for. This will aid external searches, given difficulties in some products spatial searching abilities. Note that there is no default, therefore absence = "do not know, work it out for yourself".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="includesSouthPole" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>Statement as to whether the South Pole is within the extent being searched for. This will aid external searches, given difficulties in some products spatial searching abilities. Note that there is no default, therefore absence = "do not know, work it out for yourself".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="includes180Degrees" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>Statement as to whether 180 degrees longitude is within the extent being searched for. This will aid external searches, given difficulties in some products spatial searching abilities. Note that there is no default, therefore absence = "do not know, work it out for yourself".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="dgBoundingBoxType">
		<xs:sequence>
			<xs:element name="LimitNorth" type="moles:latitudeDecimalType">
				<xs:annotation>
					<xs:documentation>Northern-most coordinate of the limit of the extent, expressed in latitude in decimal degrees (positive north).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LimitSouth" type="moles:latitudeDecimalType">
				<xs:annotation>
					<xs:documentation>Southern-most coordinate of the limit of the extent, expressed in latitude in decimal degrees (positive north).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LimitWest" type="moles:longitudeDecimalType">
				<xs:annotation>
					<xs:documentation>Western-most coordinate of the limit of the extent, expressed in longitude in decimal degrees (positive east)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LimitEast" type="moles:longitudeDecimalType">
				<xs:annotation>
					<xs:documentation>Eastern-most coordinate of the limit of the extent, expressed in longitude in decimal degrees (positive east).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgInternalPoint" type="moles:dgPoint2DType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional point that is unambiguously inside the area for those "difficult cases"</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="moles:dgSpatialInclusionAttrGrp"/>
	</xs:complexType>
	<xs:complexType name="dgMetadataRecordType">
		<xs:sequence>
			<xs:element ref="moles:dgMetadataID"/>
			<xs:element name="dgMetadataDescription" type="moles:dgMetadataDescriptionType"/>
			<xs:element name="name" type="xs:string"/>
			<xs:element name="abbreviation" type="moles:dgMandatoryStringType" nillable="true">
				<xs:annotation>
					<xs:documentation>Software should default name and abbreviation to (at least a truncated version of) the other, if only one is filled in.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="moles:logos" minOccurs="0"/>
			<xs:choice>
				<xs:element name="dgActivity" type="moles:dgActivityType"/>
				<xs:element name="dgDataEntity" type="moles:dgDataEntityType"/>
				<xs:element name="dgDataProductionTool" type="moles:dgDataProductionToolType"/>
				<xs:element name="dgObservationStation" type="moles:dgObservationStationType">
					<xs:annotation>
						<xs:documentation>IDC, may want to add info about the type and number of instruments that can be deployed... Also, really don't like the name "ObservationStation...</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element ref="moles:dgStructuredKeyword" maxOccurs="unbounded"/>
			<xs:element name="dgMetadataProvenance" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RecordCreation">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="CreatedDate" type="xs:date"/>
									<xs:element name="CreatedBy" type="xs:string"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="RecordUpdate" minOccurs="0" maxOccurs="unbounded">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="UpdateDate" type="xs:dateTime"/>
									<xs:element name="UpdatedBy" type="xs:string"/>
									<xs:element name="UpdateSummary" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="RecordReview" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="ReviewDate" type="xs:date"/>
									<xs:element name="ReviewContact" type="xs:string" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="MetadataLanguage" type="moles:dgStructuredKeywordType" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The term here should be the ISO 639-2 value, i.e. the 3 letter language code. The ID should be the numeric value specified. The standard can be viewed at http://www.loc.gov/standards/iso639-2/</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="dgMetadataSecurity" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates security applied, if any, to the metadata record itself</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dgSecurityCondition" type="moles:dgSecurityConditionType" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="dgMandatoryStringType">
		<xs:annotation>
			<xs:documentation>Restricts xs:string to ensure the string is not empty</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:minLength value="1"/>
			<xs:pattern value="(\S(\S|\s)*)|(\r\S(\S|\s)*)"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="dgParameterValueType">
		<xs:choice minOccurs="0">
			<xs:element name="dgValueDataParameter" type="moles:dgValueDataParameterType"/>
			<xs:element name="dgRangeDataParameter" type="moles:dgRangeDataParameterType"/>
			<xs:element name="dgEnumerationParameter" type="moles:dgEnumerationParameterType"/>
			<xs:element name="dgParameterGroup" type="moles:dgParameterGroupType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="dgEnumerationParameterType">
		<xs:sequence>
			<xs:element name="Value" type="xs:anySimpleType" maxOccurs="unbounded"/>
			<xs:element name="dgStandardUnit" type="moles:dgUnitType">
				<xs:annotation>
					<xs:documentation>To allow proper searching, we will need a set of reference units</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgOriginalUnit" type="moles:dgUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If we keep a reference to the units of the original measurements, if known, then it will be useful.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgRangeDataParameterType">
		<xs:sequence>
			<xs:element name="HighValue" type="xs:anySimpleType"/>
			<xs:element name="LowValue" type="xs:anySimpleType"/>
			<xs:element name="dgStandardUnit" type="moles:dgUnitType">
				<xs:annotation>
					<xs:documentation>To allow proper searching, we will need a set of reference units</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgOriginalUnit" type="moles:dgUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If we keep a reference to the units of the original measurements, if known, then it will be useful.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgValueDataParameterType">
		<xs:sequence>
			<xs:element name="Value" type="xs:anySimpleType"/>
			<xs:element name="dgStandardUnit" type="moles:dgUnitType">
				<xs:annotation>
					<xs:documentation>To allow proper searching, we will need a set of reference units</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgOriginalUnit" type="moles:dgUnitType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If we keep a reference to the units of the original measurements, if known, then it will be useful.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgParameterGroupType">
		<xs:sequence>
			<xs:element name="dgComponentParameter" type="moles:dgParameterType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgOnlineReferenceType">
		<xs:sequence>
			<xs:element name="dgCitation" type="moles:dgCitationType" minOccurs="0"/>
			<xs:choice>
				<xs:element name="dgSimpleLink" type="moles:dgSimpleLinkType"/>
				<xs:element name="dgXlink" type="xs:string"/>
			</xs:choice>
			<xs:element name="dgReferenceClass" type="moles:dgStructuredKeywordType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Allows the specification of a class of references.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgReferenceName" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Allows labelling of the reference for std. link text for example.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="dgReferenceText" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Notes or other non-title text associated with reference</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgSimpleLinkType">
		<xs:sequence>
			<xs:element name="name" type="xs:string"/>
			<xs:element name="URI" type="xs:anyURI"/>
			<xs:element name="notes" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="logos">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="logoURI" type="moles:dgOnlineReferenceType" minOccurs="0"/>
				<xs:element name="thumbnailURI" type="moles:dgOnlineReferenceType" minOccurs="0"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:simpleType name="latitudeDecimalType">
		<xs:annotation>
			<xs:documentation>Limit decimal to +/- 90 degrees</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:decimal">
			<xs:minInclusive value="-90"/>
			<xs:maxInclusive value="+90"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="longitudeDecimalType">
		<xs:restriction base="xs:decimal">
			<xs:minInclusive value="-180"/>
			<xs:maxInclusive value="+180"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="dgDatasetLanguage" type="moles:dgStructuredKeywordType">
		<xs:annotation>
			<xs:documentation>The term here should be the ISO 639-2 value, i.e. the 3 letter language code. The ID should be the numeric value specified. The standard can be viewed at http://www.loc.gov/standards/iso639-2/</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="dgActivityType">
		<xs:sequence>
			<xs:element name="relatedActivity" minOccurs="0" maxOccurs="unbounded">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="activityRelation" type="moles:dgStructuredKeywordType"/>
						<xs:element name="relatedActivityID" type="moles:dgMetadataIDType"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>dgActivityDataCollection 

This is expected to be an on-going collection process.

dgActivityDataProject 

A data collection or generation project planned as having a limited duration like ERA-40 usually including several investigations ormodel runs, even if these will not be represented 
in MOLES.

dgActivityDataCampaign 

A compound/umbrella activity, involving more than one major activity in its own 
right, such as ACSOE.

dgActivityDataInvestigation

A cruise/flight/something...
</xs:documentation>
				</xs:annotation>
				<xs:element name="dgActivityDataCollection"/>
				<xs:element name="dgActivityDataProject"/>
				<xs:element name="dgActivityDataCampaign"/>
				<xs:element name="dgActivityDataInvestigation">
					<xs:complexType>
						<xs:choice>
							<xs:element name="dgFlight"/>
							<xs:element name="dgCruise">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="dgVessel" type="moles:dgMetadataIDType"/>
										<xs:element name="portDeparture" type="moles:dgStructuredKeywordType"/>
										<xs:element name="portReturn" type="moles:dgStructuredKeywordType"/>
										<xs:element name="dgCruiseReports" minOccurs="0">
											<xs:complexType>
												<xs:choice maxOccurs="unbounded">
													<xs:element name="dgCruiseReportCitation" type="moles:dgCitationType"/>
													<xs:element name="dgCruiseReportURL" type="moles:dgOnlineReferenceType"/>
												</xs:choice>
											</xs:complexType>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:choice>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:element name="dgActivityRole">
				<xs:annotation>
					<xs:documentation>Note that this is a part of the "abstract class" dgRoles</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dgInvestigator">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgPrincipalInvestigator" type="moles:dgRoleType" maxOccurs="unbounded"/>
									<xs:element name="dgCoInvestigator" type="moles:dgRoleType" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="dgTechnicalContact" type="moles:dgRoleType" minOccurs="0"/>
						<xs:element name="dgProjectManager" type="moles:dgRoleType" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="ActivityDeployment" type="moles:dgDeploymentType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="dgActivityCoverage" type="moles:dgCoverageType" minOccurs="0"/>
			<xs:element name="ActivityDuration" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="startDate" type="xs:date"/>
						<xs:element name="endDate" type="xs:date" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgDataEntityType">
		<xs:sequence>
			<xs:element name="dgDataSetType">
				<xs:annotation>
					<xs:documentation>Contains general description of data granules within the data entity.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:annotation>
							<xs:documentation>Draft only.</xs:documentation>
						</xs:annotation>
						<xs:element name="dgSimulation" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgFeatureType" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="dgAnalysis" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgFeatureType" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="dgMeasurement" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgFeatureType" type="moles:dgStructuredKeywordType" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="dgDataGranule" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Link to DataModel, with optional description of data granules.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dataModelID" type="moles:dgMetadataIDType">
							<xs:annotation>
								<xs:documentation>See IDIssues page on Wiki</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="instance" minOccurs="0" maxOccurs="unbounded">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="URI" type="xs:anyURI"/>
									<xs:element name="format" type="xs:string">
										<xs:annotation>
											<xs:documentation>Should be from a "supported formats" list IDC</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="instanceComment" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="accessControlPolicy" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Contains either a text file giving the access control policy to the actual data granule, or a URL that points to such a document. In the long run, this is likely to be an XACML document. Note the assumption that there will be only one definitive source for such a policy.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:choice>
									<xs:element name="accessControlPolicyURL" type="xs:anyURI"/>
									<xs:element name="accessControlPolicyText" type="xs:string"/>
									<xs:element name="dgSecurityCondition" type="moles:dgSecurityConditionType" maxOccurs="unbounded"/>
								</xs:choice>
							</xs:complexType>
						</xs:element>
						<xs:element name="dgGranuleSummary" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgGranuleName" minOccurs="0"/>
									<xs:element name="dgGranuleAbbreviation" minOccurs="0"/>
									<xs:element name="dgGranuleCoverage" type="moles:dgCoverageType" minOccurs="0"/>
									<xs:element name="dgParameterSummary" type="moles:dgParameterType" maxOccurs="unbounded"/>
									<xs:element name="dgGranuleDescription" type="moles:dgMetadataDescriptionType" minOccurs="0"/>
									<xs:element ref="moles:dgDatasetLanguage" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="dgDataSummary">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dgParameterSummary" type="moles:dgParameterType" maxOccurs="unbounded"/>
						<xs:element name="dgDataCoverage" type="moles:dgCoverageType" minOccurs="0"/>
						<xs:element name="dgDatasetStatus" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgDatasetClosure">
										<xs:simpleType>
											<xs:restriction base="xs:string">
												<xs:enumeration value="no_data"/>
												<xs:enumeration value="complete"/>
												<xs:enumeration value="updating"/>
												<xs:enumeration value="incomplete"/>
											</xs:restriction>
										</xs:simpleType>
									</xs:element>
									<xs:element name="dgUpdateFrequency" type="moles:dgStructuredKeywordType" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element ref="moles:dgDatasetLanguage" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="dgDatasetProvenance" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Another placeholder for when the data provenance issue has been addressed</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="dgDataPublicationDate" type="xs:date" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="dgDataEntityQuality" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="DQStatementReference" type="moles:dgCitationType" minOccurs="0" maxOccurs="unbounded"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="dgDataRoles">
				<xs:annotation>
					<xs:documentation>Note that this is a part of the "abstract and unimplemented class" dgRoles</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="dgDataCreator" type="moles:dgRoleType" minOccurs="0"/>
						<xs:element name="dgDataCurator" type="moles:dgRoleType"/>
						<xs:element name="dgDataOtherRoles" type="moles:dgRoleType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RelatedDeployment" type="moles:dgDeploymentType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="dgRelatedDataEntity" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Relations other than Input...</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RelatedDataEntityID" type="moles:dgMetadataIDType"/>
						<xs:element name="RelationID" type="moles:dgStructuredKeywordType"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgDataProductionToolType">
		<xs:sequence>
			<xs:element name="contactDetails" type="moles:dgContactDetailType"/>
			<xs:choice>
				<xs:element name="dgModel">
					<xs:complexType/>
				</xs:element>
				<xs:element name="dgInstrument">
					<xs:annotation>
						<xs:documentation>This will be radically reworked</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="dgInstrumentComponentID" type="moles:dgMetadataIDType" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>References to significant sub-parts of an instrument</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:choice>
								<xs:element name="dgObserver">
									<xs:complexType>
										<xs:choice>
											<xs:element ref="moles:dgOrganisation"/>
											<xs:element ref="moles:dgPerson"/>
										</xs:choice>
									</xs:complexType>
								</xs:element>
								<xs:element name="dgLidar" type="xs:anySimpleType"/>
								<xs:element name="dgRadar" type="xs:anySimpleType"/>
								<xs:element name="dgSonde" type="xs:anySimpleType"/>
								<xs:element name="dgNavigation" type="xs:anySimpleType"/>
								<xs:element name="dgGasChromatograph" type="xs:anySimpleType"/>
								<xs:element name="dgSpectrometer" type="xs:anySimpleType"/>
								<xs:element name="dgMassSpectrometer" type="xs:anySimpleType"/>
								<xs:element name="dgMetSensor" type="xs:anySimpleType"/>
								<xs:element name="dgDOAS" type="xs:anySimpleType"/>
								<xs:element name="dgASOZ" type="xs:anySimpleType"/>
								<xs:element name="dgRadiometer" type="xs:anySimpleType"/>
								<xs:element name="dgFAGE" type="xs:anySimpleType"/>
								<xs:element name="dgImager" type="xs:anySimpleType"/>
								<xs:element name="dgFilter" type="xs:anySimpleType"/>
								<xs:element name="dgParticleCounter" type="xs:anySimpleType"/>
								<xs:element name="dgSampler" type="xs:anySimpleType"/>
								<xs:element name="dgOtherInstrumentType" type="xs:anySimpleType"/>
							</xs:choice>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:element name="dgDPTRoles" minOccurs="0">
				<xs:annotation>
					<xs:documentation>DPT = Data Production Tool</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="moles:dgRoleType">
							<xs:sequence>
								<xs:element name="dgDPTOperationTeam">
									<xs:annotation>
										<xs:documentation>OK, this is another placeholder and an example of the kind of role hierarchies that exist.</xs:documentation>
									</xs:annotation>
								</xs:element>
								<xs:element name="dgDPTOtherRoles" type="moles:dgRoleType" minOccurs="0"/>
							</xs:sequence>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="DPTDeployment" type="moles:dgDeploymentType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="dgObservationStationType">
		<xs:sequence>
			<xs:element name="contactDetails" type="moles:dgContactDetailType"/>
			<xs:choice>
				<xs:element name="dgStationaryPlatform">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="position">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="positionLatitude" type="xs:decimal">
											<xs:annotation>
												<xs:documentation>North is positive ;-)</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="positionLongitude" type="xs:decimal">
											<xs:annotation>
												<xs:documentation>East is positive</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
							<xs:choice>
								<xs:element name="dgLandStation"/>
								<xs:element name="dgMooring">
									<xs:complexType>
										<xs:sequence>
											<xs:element name="dateStart" type="xs:date"/>
											<xs:element name="dateEnd" type="xs:date"/>
											<xs:element name="deployingCruise" type="moles:dgMetadataIDType">
												<xs:annotation>
													<xs:documentation>Pointer to cruise that deployed the platform</xs:documentation>
												</xs:annotation>
											</xs:element>
											<xs:element name="dgStationGrouping" type="moles:dgMetadataIDType" minOccurs="0">
												<xs:annotation>
													<xs:documentation>Pointer to the OS of type dgStationGroup at which the mooring was deployed, if any.</xs:documentation>
												</xs:annotation>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
								<xs:element name="dgStationGroup">
									<xs:annotation>
										<xs:documentation>The solution to the Great Station Controvesy! This is a known and defined location at which temporary observation stations, such as moorings, can be located. Note that current thinking is that it can't have data of its own. The apparently redundant grouping is to allow the dgStationGroup to have other elements attached in the future</xs:documentation>
									</xs:annotation>
									<xs:complexType>
										<xs:sequence>
											<xs:element name="dgGroupedStations" minOccurs="0">
												<xs:complexType>
													<xs:sequence>
														<xs:element name="dgGroupedStation" type="moles:dgMetadataIDType" maxOccurs="unbounded">
															<xs:annotation>
																<xs:documentation>Pointer to mooring or similar at this location.</xs:documentation>
															</xs:annotation>
														</xs:element>
													</xs:sequence>
												</xs:complexType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
							</xs:choice>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="dgMovingPlatform">
					<xs:annotation>
						<xs:documentation>Used to contain "trajectory", this has been replaced by the "Coverage" element of a deployment. However, adding a "history" element may well be useful, to include trips not linked to data etc.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:choice>
								<xs:element name="dgShip">
									<xs:complexType>
										<xs:sequence>
											<xs:element name="callSign" type="xs:string" minOccurs="0"/>
											<xs:element name="operatingCountry" type="xs:string">
												<xs:annotation>
													<xs:documentation>Contents ISO 3166-1 and 3166-3, using 2 character code as key</xs:documentation>
												</xs:annotation>
											</xs:element>
											<xs:element name="vesselType" type="moles:dgStructuredKeywordType" maxOccurs="unbounded">
												<xs:annotation>
													<xs:documentation>Allows referencing to standard classification schemes such as WMO and SeaDataNet</xs:documentation>
												</xs:annotation>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
								<xs:element name="dgAircraft"/>
								<xs:element name="dgSatellite"/>
							</xs:choice>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:element name="ObsStationDeployment" type="moles:dgDeploymentType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
</xs:schema>
